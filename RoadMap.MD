### Точка входа

Точкой входа является REST-Апи. Предоставляет следующие методы:

   1. Выполнить рассылку:
      - описание: основной метод, выполняет асинхронную регистрацию отправки сообщения в нужном виртуальном канале, отдает ответ не дожидаясь выполнения отправки
      - структура URL: /api/send/{virtual-channel-name}
      - метод POST (регистрация рассылки)
      - заголовки: Charset: UTF-8, Content-Type: application/x-www-form-urlencoded
      - тело: json-объект, содержащий в себе следующие данные: 
         - message: обязателен, однострочная или многострочная строка, допустимы латинские и кириллические символы, а также знаки препинания
         - delay: опционален, задержка отправки сообщений (в секундах) после регистрации, если не передан - отправка без задержки
         - attempts: опционален, число попыток отправить сообщение, после которого запрос считается безуспешным, если не передан - значение берется из конфигурации
         - timeout: опционален, число секунд прошедшее с регистрации, после которого запрос считается безуспешным, если не передан - значение берется из конфигурации
         - failDelay: опционален, число секунд после неудачной попытки отправки, после которого выполняется новая попытка, если не передан - значение берется из конфигурации
      - ответ: 200, json объект с идентификатором задачи в очереди при успешной регистрации; 500, json объект с кодом и описанием ошибки в случае ошибок выполнения; 422, json объект с кодом и описанием ошибки в случае ошибок валидации входящих данных
   2. Задание в очереди:
      - описание: вспомогательный метод, позволяет работать с определенной рассылкой по ее идентификатору
      - структура URL: /api/message/{send-id}
      - методы GET (получить данные рассылки), DELETE (удалить рассылку), PATCH (изменить данные рассылки, если оно еще не отправлено)
      - заголовки: Charset: UTF-8, Content-Type: application/x-www-form-urlencoded (для PATCH)
      - тело: не требуется для GET и DELETE, для PATCH json-объект с массивом изменений, аналогичен ключам в "выполнить рассылку", а также ключ pause со значением секунд, на которое откладывается выполнение задачи (в отличие от delay смещаются все временные границы)
      - ответ: 200, json объект с данными рассылки (только для GET); 204, без данных (для DELETE и PATCH); 500, json объект с кодом и описанием ошибки в случае ошибок выполнения; 404, в случае недоступности рассылки для выбранного действия; 422, json объект с кодом и описанием ошибки в случае ошибок валидации входящих данных
   3. Повторить рассылку:
      - описание: вспомогательный метод, позволяет выполнить новую рассылку по шаблону уже выполненной
      - структура URL: /api/resend/{send-id}
      - метод GET
      - заголовки: Charset: UTF-8
      - тело: не требуется
      - ответ: 200, json объект с данными новой рассылки; 500, json объект с кодом и описанием ошибки в случае ошибок выполнения; 404, в случае, если указанная рассылка не найдена
   4. Очередь:
      - описание: вспомогательный метод, позволяет работать с очередью еще не отправленных сообщений
      - структура URL: /api/queue
      - методы GET (получить очередь еще не отправленных сообщений), DELETE (удалить из очереди еще не отправленные сообщений)
      - заголовки: Charset: UTF-8
      - тело: не требуется
      - ответ: 200, json объект со списком задач и их описанием (только для GET); 204, без данных (для DELETE); 500, json объект с кодом и описанием ошибки в случае ошибок выполнения
   5. Очистка:
      - описание: вспомогательный метод, позволяет работать с уже отправленными сообщениями
      - структура URL: /api/completed
      - методы GET (получить очередь уже отправленных сообщений), DELETE (очистить очередь уже отправленных сообщений)
      - заголовки: Charset: UTF-8
      - тело: не требуется
      - ответ: 200, json объект со списком задач и их описанием (только для GET); 204, без данных (для DELETE); 500, json объект с кодом и описанием ошибки в случае ошибок выполнения
   6. Общее состояние сервиса:
      - описание: служебный метод, позволяет узнать состояние сервиса или изменить его
      - структура URL: /api/status
      - методы GET (получить текущее состояние сервиса), PUT (изменить состояние сервиса)
      - заголовки: Charset: UTF-8, Content-Type: application/x-www-form-urlencoded (для PUT)
      - тело: json-объект с единственным ключом status (только для PUT)
      - ответ: 200, json объект с текущим состоянием сервиса (только для GET); 204, без данных (для DELETE); 500, json объект с кодом и описанием ошибки в случае ошибок выполнения; 422, json объект с кодом и описанием ошибки в случае ошибок валидации входящих данных

### Обработка запросов

Жизненный цикл запросов:

   1. Для основного метода:
      1. ставиться lock на выполнение заданий из очереди
      2. получение данных из запроса
      3. валидация данных
      4. размещение задания в очереди
      5. если нет задания на обработку очереди - создается задание на обработку очереди в multi-tread режиме, если задание есть - шаг пропускается
      6. отдает http-ответ с результатом выполнения операции (не дожидаясь выполнения задания на обработку очереди)
      7. снимается lock на выполнение заданий из очереди
   2. Для вспомогательных методов:
      1. ставиться lock на выполнение заданий из очереди
      2. получение данных из запроса
      3. валидация данных, если это предусмотрено запросом
      4. Далее:
         - если запрос подразумевает только получение данных по задаче/очереди - получаем эти данные и возвращаем http-ответ с данными
         - если запрос подразумевает изменение данных задачи или удаление задачи - снимаем задачу с очереди (убираем из очереди), изменяем задачу и возвращаем задачу в конец очереди, возвращаем пустой http-ответ
         - если запрос подразумевает изменение очереди - изменяем очередь и возвращаем пустой http-ответ
      5. снимается lock на выполнение заданий из очереди
   3. Для служебного метода "Общее состояние сервиса" - получение состояния сервиса:
      1. читается содержимое очереди:
         - если установлен lock по состоянию сервиса - возвращаем http-ответ с состоянием DOWN
         - если очередь пуста - возвращаем http-ответ с состоянием IDLE
         - если в очереди присутствуют активные задания и есть lock по выполнению основного или вспомогательного запросов - возвращаем http-ответ с состоянием ACTIVE
         - если в очереди присутствуют активные задания, но нет lock по выполнению основного или вспомогательного запросов - возвращаем http-ответ с состоянием WAITING
   4. Для служебного метода "Общее состояние сервиса" - изменение состояние сервиса:
      1. ставиться lock на выполнение заданий из очереди
      2. получение данных из запроса
      3. валидация данных
      4. далее
         - если запрос подразумевает остановку сервиса - ставим lock сервиса и возвращаем пустой http-ответ
         - если запрос подразумевает запуск сервиса - снимаем lock сервиса и возвращаем пустой http-ответ
      5. снимается lock на выполнение заданий из очереди

### Состояние сервиса

   1. Подразумевается, что можно через апи, минуя прямой доступ на сервер, где развернут сервис, управлять его работой 
   2. Есть два состояния - остановлен и работает (с группой дочерних статусов):
      - если сервис остановлен, выполнение задач из очереди приостановлено, временные задач границы не смещаются - при возобновлении работы, задания чье время ожидания вышло за пределы ожидания считаются проваленными
      - если сервис запущен, задания выполняются в установленно порядке, в зависимости от наличия не выполненных заданий в очереди и их выполнения в текущий момент возвращается один из дочерних статусов

### Валидация данных

   1. все входящие данные можно разделить на две группы:
      - управляющие, данные, которые влияют на поведение сервиса и очереди
      - пользовательские, данные, которые проходят через сервис и не влияют на его поведение
   2. Общие правила, применяемые ко всем валидируемым данным:
      - обязательное поле, сервис обязан вернуть ошибку, в случае если поле не представлено или его значение пусто (пустая строка, None)
   3. Правила, применяемые к управляющим данным:
      - число, значением поля является целое число, либо строка состоящая только из цифр и возможного знака минус в начале
      - строка, значением поля является непустая строка без знаков переноса строки и перевода каретки (\n или \r\n)
   4. Правила, применяемые к пользовательским данным:
      - текст, определяется исполнителем задания - шаблон регулярного выражения предоставляет исполнитель задания, данный шаблон позволяет проверить текст на соответствие параметрам сервиса, в который передается задание
      
### Логирование:

Варианты и точки:
  - стандартные средства nginx
  - стандартные средства python
  - обертка для режима отладки и verbose-level
  - дополнительное логирование с сохранением логов в БД/файлы
  
### Очередь

У данного модуля в кодовой базе имеется абстрактный класс/интерфейс, соответствующий тем функциям, которые будут вызываться при создании задания в очередь - это позволит создавать обертки для сторонних сервисов, реализующих очередь

Модуль по работе с заданиями в очереди имеет следующие методы:
   1. создать задание:
      - аргументы: исполнитель задания (объект, скорее всего json), задержка перед выполнением задания (число), время на выполнение задания (число), количество попыток (число), задержка между попытками (число)
      - при выполнении может выбрасывать исключения
      - возвращаемое значение: число
   2. получить данные задания:
      - аргументы: идентификатор задания (число)
      - при выполнении может выбрасывать исключения
      - возвращаемое значение: хеш-таблица
   3. изменить задание:
      - аргументы: массив изменяемых значений (хеш-таблица, где ключ - имя параметра, значение - новое значение параметра) 
      - при выполнении может выбрасывать исключения
      - возвращаемое значение: успешность операции (булев тип) 
   4. удалить задание:
      - аргументы: идентификатор задания (число)
      - при выполнении может выбрасывать исключения
      - возвращаемое значение: успешность операции (булев тип)
   5. получить список заданий:
      - аргументы: активные задания (булев тип)
      - при выполнении может выбрасывать исключения
      - возвращаемое значение: хеш-таблица
   6. удалить список заданий:
      - аргументы: активные задания (булев тип)
      - при выполнении может выбрасывать исключения
      - возвращаемое значение: успешность операции (булев тип)
   7. отложить задание:
      - аргументы: идентификатор задания (число)
      - при выполнении может выбрасывать исключения
      - возвращаемое значение: успешность операции (булев тип)

Все задания - корутины, сама очередь имеет тип FIFO

Задания в очереди имеют:
 
   - тайм-аут - время, после которого задание считается проваленным (значение по умолчанию определяется в конфигурации)
   - число попыток, после которого задание считается проваленным (значение по умолчанию определяется в конфигурации)
   - задержка перед стартом выполнения задания, тайм-аут стартует после истечения задержки перед выполнением (значение по умолчанию определяется в конфигурации)
   - задержка между попытками - задержка перед повторной попыткой после неудачи (значение по умолчанию определяется в конфигурации)

Исполнитель задания имеет два lock - при запросе и сервисный. Первый ставиться при выполнении некоторых запросов и снимается после их выполнения, при этом выполнение заданий ставиться на паузу. Второй ставиться и снимается служебным запросом, при этом выполнение заданий также ставится на паузу

Исполнитель задания получает данные задания из очереди, формирует объект задания по виртуальному каналу, и выполняет стандартный метод в объекте задания

Если задание выполнить не удалось - объект задания выбросил исключение, задание перемещается в конец очереди или, если задана задержка перед следующей попыткой - на ожидание

Если задание выполнено - задание помечается как выполненное (переносится в очередь/список выполненных), объект задания удаляется

### Виртуальный канал

Виртуальным каналом называется виртуальное имя объекта задания, а также произвольный набор настроек и свойств дял объекта задания - это подразумевает наличие неограниченного числа виртуальных каналов для одного объекта задания. Это в свою очередь позволяет выполнять задания в разных условиях, например, выполнять почтовую рассылку по разным почтовым адресам или отправлять сообщения от разных ботов в различные чаты одного и того же сервиса

Виртуальные каналы настраиваются в соответствующем конфигурационном файле с расширением YAML. В соответствующем перечне ключами являются имена каналов, а значениями - реальное имя объекта задания, а также настройки объекта задания

Конфигурация виртуальных каналов читается в память/кеш при старте сервиса и не может быть изменена без его остановки

### Объект задания

Представлен абстрактный класс/интерфейс, в котором объявлены основные методы, вызываемые сервисом. Для создания объекта задания наследуется данный класс/интерфейс

Объект задания пытается:

   1. подключится к целевому сервису/службе
   2. передать сообщение
   3. получить ответ и разобрать его

Запросы выполняются асинхронно. При возникновении ошибки подключения или выполнения запроса выбрасывается исключение

Предполагается реализовать следующие объекты заданий:

   1. Telegram-bot - подключение к Telegram и передача сообщения в определенный чат
   2. Mock объект - данный объект не выполняет подключений, пишет только в логи свой вызов (скорее всего для тестов)
   3. SMS - рассылка по определенному набору номеров короткого сообщения через внешний сервис рассылки SMS-сообщений
   4. email - рассылка текстового сообщения набору адресов через внешний сервис почты

### План реализации

MVP предполагает:

   1. создание http сервера, на котором реализовано REST апи с одним методом - основным. Метод в первично реализации не принимает параметры по тайм-аутам, задержкам и числу попыток
   2. создание единственного метода в менеджере очереди - создать задание. Очередь содержит только активные задания
   3. создание исполнителя задания
   4. Объект задания по отправке сообщений в Телегу
   5. поддержка виртуальных каналов должна быть заложена, но на текущий момент конфигурация под единственный объект задания

Далее следующий функционал:

  1. Полноценная реализация виртуальных каналов
  2. Добавление Mock-объекта задания
  3. Добавление базового набора тестов
  4. Настройка CI/CD
  5. Добавление возможностей основного метода:
     1. задержка выполнения
     2. ограничение числа попыток
     3. задержка между попытками
     4. тайм-аут задания
  6. Расширение состава методов в следующем порядке:
     1. получение списка активных заданий из очереди
     2. получение данных задания
     3. удаление задания
     4. изменение задания
     5. копирование задания
     6. отложить задание
     7. добавление поддержки очереди/списка выполненных заданий
     8. получение списка выполненных/проваленных заданий
     9. очистка списка/очереди
     10. статус сервиса
     11. изменение статуса сервиса
  7. Добавление не хватающих тестов (планируется выпуск тестов совместно с функциями, но может чего не хватать)
  8. Предрелизный рефакторинг 
  9. Релиз версии 1.0
  10. Добавление объектов заданий в качестве пакетов расширений

### Вопросы/возможные фичи:
   
   1. Сервер конечно сидит во внутренней сети, но это не отменяет необходимости как-то регулировать доступ к ресурсам точки входа. Отсюда следует необходимость модуля аутентификации и авторизации. Это может быть как самостоятельное решение, основанное на ключах, так и привязка к LDAP/PAM
   2. Бесшовная интеграция - предоставление функций точки входа в виде готового куска HTML для интеграции в качестве iframe, с возможностью онлайн-мониторинга и GUI управлением
   3. нужен ли нам под это докер (сразу/вообще) или pipenv/venv будет достаточно?
   4. Если я правильно понял - aiohttp самостоятельно слушает сеть: нужен ли учет nginx 
